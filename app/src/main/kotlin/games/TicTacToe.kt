/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package games

import java.text.MessageFormat
import java.util.*


// Think about generalizing this to a game class and dropping in a tictactoe variant of it.
// Maybe create the players after the game and board is created. The game wouldn't be playable
// until sufficient players have arrived.
// Not very testable.
class TicTacToe(
        val player1: Player = HumanPlayer(name = "Lianne", id = 1, TextInputController()),
        val player2: Player = ComputerPlayer(name = "Paul", id = 2, CompositeStrategy(listOf
        (Offensive(), Defensive())))
) {
    internal val board = Board()
    private val displayer = TextDisplayer()
    private var winner:Player? = null

    init {
        player1.setOpponent(player2)
        player2.setOpponent(player1)
    }

    //    /// Print the updated board after every move
    fun printBoard() {
        return displayer.display(board)
    }

    //
    fun playGame(moveHistory: MutableList<MoveCommand>) {
        val rb = ResourceBundle.getBundle("tic_tac_toe")
        println(rb.getString("welcomeMessage"))
        val interval = rb.getString("intervalWeek")
        val offer = MessageFormat.format(rb.getString("subOffer"), 12.99, interval)
        println(offer)

        printBoard()
        var curPlayer = player1
        while(moveHistory.size != 9) {
            val validMoves = board.getValidMoves()
            try {
                val move = curPlayer.makeMove(board, validMoves)
                makeMove(curPlayer, move, moveHistory)
                if (winner != null) {
                    print("${winner?.name} has Won!")
                    break
                }
            } catch (u: UndoException) {
                if (moveHistory.isNullOrEmpty()) {
                    print("Cannot undo with no moves. \n")
                }
                else {
                    undoLastMove(moveHistory)
                }
            } finally {
                curPlayer = curPlayer.opponent()
            }
            printBoard()
        }
    }

    internal fun undoLastMove(moveHistory: MutableList<MoveCommand>) {
        val lastCommand = moveHistory.removeLast()
        lastCommand.undo()
    }

    internal fun makeMove(curPlayer: Player, move: Move, moveHistory: MutableList<MoveCommand>) {
        val command = MoveCommand(board, curPlayer, move)
        command.apply()
        moveHistory.add(command)
        winner = WinnerDetector().detectWinner(board, player1, player2)
    }

    fun getWinner(): Player? {
        return winner
    }

    internal fun setState(gameState: String) {
        board.setState(gameState)
    }

}


fun main() {
    TicTacToe().playGame(mutableListOf<MoveCommand>())
}
